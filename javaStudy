//收集到set集合当中
list.stream().filter(s->"男".equals(s.split("-")[1]))
	.collect(Collectors.toSet());
	
//收集到map中
//谁作为键，谁作为值
//把所有男性收集起来，键：姓名，值：年龄
//toMap中的参数：参数一：键的规则，参数二：值的规则
//apply形参：依次表示流里面每一个数据
//方法体：生成键/值并返回已经生成的键/值
list.stream().filter(s->"男".equals(s.split("-")[1]))
	.collect(Collectors.toMap(new Function<String/表示流里面数据的类型,String/表示map集合当中键的类型>(){
	@override
	public String apply(String s){
		return s.split("-")[0];
	}
	}，new Function<String/表示流里面数据的类型,Integer/表示map集合当中值的类型>(){
	@override
	public Integer apply(String s){
		return Integer.parseInt(s.split("-")[2]);
	}
	}));
	
//引用成员方法
格式：对象::成员方法
如果引用的是其他类：其他类对象::方法名
本类：this::方法名
父类:super::方法名

//引用构造方法
格式：类名::new
范例:Student::new
ArrayList<String> list = new ArrayList<>();
Collectors.addAll(list,"张三,21","李四,58","王五,64");
//将集合中的字符串转换为对象
list.stream().map(new Function<String,Student>(){
	@override
	public Student apply(String s){
		String[] arr = s.split(",");
		String name = arr[0];
		int age = Integer.parseInt(arr[1]);
		return new Student(name,age);
	}
}).collect(Collectors.toList());
//方法引用
Student类：
public Student(){

}

public Student(String s){
	//s表示流里的每一个数据
	String[] arr = s.split(",");
	String name = arr[0];
	int age = Integer.parseInt(arr[1]);
	return new Student(name,age);
}

public Student(String name,int age){

}

//直接使用Student::new会报错，因为方法引用第三条守则规定需要方法引用的形参和返回值与函数式接口中的一致，Student的形参是String，int，返回值是Student 而函数式接口的形参是String，返回值是Student
//解决办法，在Student中加一个只带String形参的构造方法
list.stream().map(Student::new)
